---
title: "Module 1, Introduction to the `tidyverse`"
author: "Keaton Wilson, Ellen Bledsoe"
date: "12/4/2019, revised November 2023"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

# 2-Dimensional Data and the `tidyverse`

## Learning Outcomes

-   Students will be able to load packages.
-   Students will be able to use some functions of the tidyverse: select, filter, the pipe, mutate, summarize, and group by.
-   Students will compare and contrast base R and tidyverse methodology for sub-setting data frames.
-   Students will able to use tidyverse functions to summarize real-world data.

## The `tidyverse`: What Is It?

Different programming languages have different syntax (language structure). The `tidyverse` is a package (more accurately, a set of packages) offered in R that all have similar goals and a unified syntax designed to work particularly well with 2-dimensional data.

Until now, all of the coding we have done is in the original R language, which is often called "base R." The syntax in the `tidyverse` is often pretty different from base R. Both are useful, and many people often combine them, which is why we start with base R.

That said, we will be primarily using the `tidyverse` for the rest of the semester. With the exception of Module 1 Assignment 3, which is exclusively about `tidyverse`, I will never punish you for using base R in place of `tidyverse`, as long as you get the same answer!

## Wait, What is a Package??

Packages are one of the neatest things of working in an open-source environment like R! They contains bits of code (often in the form of functions) that can be reused, making them a core component of reproducible data science. Anyone can develop a package, and there are thousands of them doing all sorts of things.

## Explore the `tidyverse`

If you want to learn more about the tidyverse, head over to [www.tidyverse.org](www.tidyverse.org) and browse the site. Below is a brief summary of *some* of the packages I think you might find the most useful.

-   `tidyr`: Creating data that is consistent in form/shape.
-   `dplyr`: Creating data that is clean, easily wrangled, and summarized.
-   `ggplot2`: Publication-worthy plots using The Grammar of Graphics.
-   `tibble`: Data frames... but better!
-   `readr`: Fast and friendly ways to read data into R.
-   `stringr`: Easy manipulation of strings (character data).
-   `lubridate`: Easy manipulation of time and date values.

## Practice with the `tidyverse`

### Download and Install

In most scenarios, you will need to download a package from the internet onto your computer before you can use it in RStudio. However, with RStudio Cloud, I've already done this step for you!

For future reference, though:

-   You usually only need to go through this process once until you update R.
-   We use the function `install.packages()` to download the package.

```{r install_tidyverse, message = FALSE}

# Download and install the tidyverse package(s)
# to run the line of code, remove the # in front of the line below and run this chunk
# install.packages("tidyverse")

```

### Loading Into R

Any time we open R/RStudio and want to use functions from the `tidyverse` (or other packages), we need to "load" the package. We use the `library()` function to do this.

When you run this code, you'll see a message that says "Attaching packages" and "Conflicts." Don't panic!

-   The first bit tells us that the core packages have been brought into our R session.
-   The "conflict" part is a little more complicated but we don't need to worry too much about it.
    -   If you're curious, though, it is telling us that there are some functions in the `tidyverse` that have the same names as functions that are automatically installed with R and that the `tidyverse` versions of those functions will be the ones that get used by default unless we specify otherwise.

```{r load_tidyverse, message = FALSE}

# Load the tidyverse (tell RStudio we want to use this package in this session)
library(tidyverse)


```

## Climate Data

To learn about the `tidyverse` syntax, we're going to use a real data set on climate change from Berkeley, CA, USA. It outlines temperatures in major cities across the world since 1750.

```{r climate_data}

# Read in the data file

# `read_csv()` is part of the `tidyverse` and gives us nice options when reading in data
climate_df <- read_csv("global_temps.csv")

# Let's take a look at the climate data
climate_df

```

The `tidyverse` converts 2D data into something called a tibble! For our intents and purposes, it is basically the same as a data frame (and I'll probably call it a data frame, in reality).

Let's take a look at our tibble (AKA data frame).

```{r}

# Explore the data set

# Gives first 6 rows of the data frame
head(climate_df)

# Tells us the structure of the data frame
str(climate_df)

```

## `select()`ing columns

Let's use our first function, `select()`. Select allows us to pick out specific columns from our data. You can use names or their position in the data frame.

First, let's remind ourselves how we would accomplish this in base R.

```{r select_baseR}

# Column selection in base R

# One way to select the columns is by the format dataframe$column
# If all else works, R should list all the columns in the data frame for you to pick from the moment you add the "$" 
# climate_df$dt

# Alternatively we can use indexing to select columns
# Recall that [row, column] is why there is a comma in there
climate_df[,1:2]

```

The `select()` function does the same thing but with more power (and, in my opinion, more easily). The first argument in the function is the data frame. Any following arguments are the columns we want to select.

```{r select_tidy}

# First argument is the data frame, then the columns you want
select(climate_df, dt)

# Multiple columns

# Listing out the columns you want
select(climate_df, dt, City, Country)

# Selecting columns from a to b
select(climate_df, dt:Country)

# Selecting all columns EXCEPT what is listed
select(climate_df, -City)

```

You might have noticed that we haven't put any column names in quotations, unlike what we did with selecting columns by name in base R. This is one quirk of the `tidyverse` to which you will need to pay special attention. We *usually* will not need to put column names in quotations.

### Let's practice!

Write a line of code to select the following data from the `climate_df`: average temperature, latitude and longitude

```{r}

select(climate_df, AverageTemperature, Latitude, Longitude)

```

It is important to remember that the computer interprets everything literally. We need to tell the function the **exact** names of the columns. R will interpret `latitude` and `Latitude` as different things; it doesn't know that they are probably the same!

## `filter()`ing rows

`filter()` allows you filter rows by certain conditions. Recall that we did this a bit with base R.

```{r filter_baseR}

# Base R
climate_df[climate_df$AverageTemperature > 25, ]

```

The code above is, in my opinion, a bit unwieldy. Filter feels more intuitive. We still need the double equal signs, though!

```{r filter_tidy}

# Filter all average temperatures greater than 25
filter(climate_df, AverageTemperature > 25)

# It is easy to write multiple conditions and to chain stuff together

# Only rows that meet both conditions
# (Could also use "&" instead of ",")
filter(climate_df, AverageTemperature > 25, Country == "United States")   

# Rows that meet one or the other condition
# (The "|" symbol means `or`)
# (P.S. That is not a capital i or a lowercase l)
filter(climate_df, AverageTemperature > 25 | Country == "United States" ) 

# Pulls rows in which the Country column has either "United States" OR "Mexico"
filter(climate_df, Country == "United States" | Country == "Mexico")      

# It is worth noting here that we haven't saved any of this. We need to write to a new object. 
us_df <- filter(climate_df, AverageTemperature > 25)

```

### Let's Practice Using `select()` and `filter()`

Work with the climate data we've been using this class period. Construct a small set of code that does the following:

1.  Slims down the full data frame to one that contains the columns dt, AverageTemperature and City. Assign this to an object called `slim`.
2.  Filters the data for Paris with an average temperature less than 22.
3.  Name this new data frame "cold_paris"

```{r}

# Not piped 
# (Meaning not executed all in one go, each of these lines has to be run)

slim <- select(climate_df, dt, AverageTemperature, City)

filtered <- filter(slim, City == "Paris", AverageTemperature < 22)

cold_paris <- filtered

```

## The Pipe `%>%`

You can use the pipe operator to chain tidyverse functions together. You can think of the pipe as automatically sending the output from the first line into the next line as the input.

This is helpful for a lot of reasons, including:

1.  Removing the clutter of creating a lot of intermediate objects in your work space, which reduces the chance of errors caused by using the wrong input object.
2.  Makes things more human-readable (in addition to computer-readable).

The shortcut for typing a pipe is `Ctrl` + `Shift` + `M` (or `Cmd` + `Shift` + `M` on a Mac).

```{r pipes}

# What is happening here?
# 1) Open data frame
# 2) Select columns

climate_df %>% 
  select(dt, City)

# What about here?
# 1) cold_paris is the object our results will be stored in
# 2) Open data frame
# 3) Select columns
# 4) Filter Paris observations AND where average temperature there was less than 22 degrees

cold_paris <- climate_df %>%
  select(dt, AverageTemperature, City) %>%
  filter(City == "Paris", AverageTemperature < 22)

```

### Let's Practice!

In small groups, use pipes to create a new data frame called `warm_nigeria` that includes the following:

-   The columns AverageTemperature, City, Country.
-   Only rows for the country Nigeria.
-   Temperatures that are greater than 30 degrees.

```{r nigeria30}

warm_nigeria <- climate_df %>% 
  select(AverageTemperature, City, Country) %>% 
  filter(Country == "Nigeria", AverageTemperature > 30)

```

## Creating New Variables with `mutate()`

Sometimes our data isn't formatted exactly how we want. For example, we might want our temperature data in Fahrenheit instead of Celsius.

The `tidyverse` has a function called `mutate()` that lets us create a new column and fill it with what we want. 

Often, we want to apply a function to the entire column or perform some type of calculation, such as converting temp from F to C.

To help us out, here is the equation for converting F to C: `Fahrenheit = Celsius * (9/5) + 32`

```{r mutate}

# Create a new column for temps in Fahrenheit
climate_df %>% 
  select(dt, AverageTemperature) %>% 
  mutate(AverageTemperature_F = AverageTemperature * (9/5) + 32)

```

The first part of the argument in the mutate function (before the `=`) is the name of the new column we want to create (or, sometime, the name of a column we want to overwrite). After the `=` is what we want the new column to contain.

## Understanding data through `summarize()`

Like we have talked about in previous classes, some of the best ways for us to understand our data is through what we call summary statistics such as the mean, standard deviation, minimums, maximums, etc.

Fortunately, the `tidyverse` has a handy-dandy function to make this easy to do with data frames.

The `summarize()` function creates a new dataframe with columns and values we give it. Similar to `mutate()`, what is on the left of the `=` is the name of the new column, and what is on the right of the `=` is the value(s) to put in the new column.

```{r summarize}

# First attempt at making new columns of the mean and sd of average temperature
climate_df %>% 
  summarise(mean_temp = mean(AverageTemperature),
            sd_temp = sd(AverageTemperature))

```

Wait a second! Those are some weird values!

`NA` is used to represent missing data. So what is happening here? We know that there are numbers to calculate these values.

It is important to note that if any of the values in the column that you are trying to summarize are missing (`NA`), you might get some wonky values, like you did above.

Fortunately, `mean()` and `sd()` and some other functions have an argument to remove the missing values: `na.rm = TRUE`

```{r summarize_na.rm}

climate_df %>% 
  summarise(mean_temp = mean(AverageTemperature, na.rm = TRUE),
            sd_temp = sd(AverageTemperature, na.rm = TRUE))

```

Pay attention to where the `na.rm = TRUE` argument is placed. We are putting it inside the parentheses for the `mean()` and `sd()` function, not as an argument in the `summarize()` function.

A lot of errors in R can occur if you misplace an argument, or even just a little comma.

## Split, Apply, Combine with `group_by()`

One common way we analyze data is through something we call the "split, apply, combine" approach. This means that we:

-   *Split* data up into groups via some type of categorization,
-   *Apply* some type of analysis to each group independently and,
-   *Combine* the data back together.

The `group_by()` function lets us do this. It is most often used in combination with `mutate()` or `summarize()`.

For example, we can use this method to calculate the mean temperatures of **each** country instead of the overall mean of the entire dataset. In order to do these, we create groups in the data based on the country.

```{r group_by}

climate_df %>% 
  group_by(Country) %>% 
  summarise(mean_temp = mean(AverageTemperature, na.rm = TRUE),
            sd_temp = sd(AverageTemperature, na.rm = TRUE))

```

### Let's Practice!

Practice using the combination of `group_by()` and `summarize()` to calculate the minimum (`min()`) and maximum (`max()`) average temperatures for each city. 

Save this data frame as `city_min_max`

```{r group_by_city}

climate_df %>% 
  group_by(City) %>% 
  summarize(min_temp = min(AverageTemperature, na.rm = TRUE),
            max_temp = max(AverageTemperature, na.rm = TRUE))

```

Already accomplished this task? 

Try to figure out how you can keep the "Country" column in the final data frame. This is trickier than you might think!

```{r group_by_city_country}

climate_df %>% 
  group_by(Country, City) %>% 
  summarize(min_temp = min(AverageTemperature, na.rm = TRUE),
            max_temp = max(AverageTemperature, na.rm = TRUE))

```
